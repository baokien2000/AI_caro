# -*- coding: utf-8 -*-
"""CaroMinimax.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H23QfLdUCuTRREHA0rjJJDgwosacP7rP
"""

from tkinter import *
import tkinter
from functools import partial 
from tkinter import messagebox
import numpy as np
from tkinter.font import Font
from math import inf

def get_patterns(line,pattern_dic,sym):
    i=0
    s=''
    while i<len(line):
        if line[i]== sym:
            s=s+sym
        if line[i] != sym or i == len(line)-1:
            if s in pattern_dic.keys():
                pattern_dic[s]+=1
            else:
                pattern_dic[s]=1
            s=''
        i+=1

#lấy theo hàng
def get_pattern_for_Row(pattern_dic,B):
    for i in range(B.shape[0]):
        get_patterns(B[i],pattern_dic,'X')
    for i in range(B.shape[0]):
        get_patterns(B[i],pattern_dic,'O')

# lấy theo cột 
def get_pattern_for_Column(pattern_dic,B):
    T = B.T
    for i in range(T.shape[0]):
        get_patterns(T[i],pattern_dic,'X')
    for i in range(T.shape[0]):
        get_patterns(T[i],pattern_dic,'O')

# lấy theo hàng chéo 
def get_pattern_for_Diagonal(pattern_dic,B):
    for i in range(-B.shape[0]+1,B.shape[0]):
        get_patterns(B.diagonal(i),pattern_dic,'O')
    A = B[::-1,:]
    for i in range(-A.shape[0]+1,A.shape[0]):
        get_patterns(A.diagonal(i),pattern_dic,'O')
    
    for i in range(-B.shape[0]+1,B.shape[0]):
        get_patterns(B.diagonal(i),pattern_dic,'X')
    A = B[::-1,:]
    for i in range(-A.shape[0]+1,A.shape[0]):
        get_patterns(A.diagonal(i),pattern_dic,'X')

def get_all_patterns(B):
    pattern_dic={}
    get_pattern_for_Row(pattern_dic,B)
    get_pattern_for_Column(pattern_dic,B)
    get_pattern_for_Diagonal(pattern_dic,B)
    return pattern_dic

def won(B):
    pattern_dic={}
    pattern_dic = get_all_patterns(B)
    
    #đặt trong try để tránh bị lỗi , vì lúc đầu không tồn tại 5X trong pattern_dic
    try:
        #tim trong pattern_dic neu ton tại 5X 
        if pattern_dic['XXXXX'] >= 1:
            # in ra bảng thông báo winner 
            messagebox.showinfo('Winner','X win ')
            # xóa bảng(giao diện) 
            tk.destroy()
            # trả về 0 
            return 0
    except Exception as e:
        pass
    # tương tự ở trên
    try:
        if pattern_dic['OOOOO']>= 1:
            messagebox.showinfo('Winner','O win')
            tk.destroy()
            return 1
    except Exception as e:
        pass
    # gán n bằng 0 
    n=0
    #chạy từng dòng trong B , với S = 3 
    for i in range (S):
        for j in range (S):
            # nếu trong B có ô trống thì n + 1 
            if B[i,j] == '':
                n+=1
    # chạy xong ở trên mà n vẫn = 0 -> full bảng             
    if n == 0:
        # in ra Hòa
        messagebox.showinfo('Winner','Hòa ')
        tk.destroy()
        return 3 
    # nếu không rơi vào 3 cái trên thì trả về none
    return None

def Empty(B): # hàm kiểm tra các nước chưa đánh trong bàn cờ 
    E = [] # rồi thêm vào E 
    for i in range (S):
        for j in range(S):
            if B[i,j] == '':
                E.append([i,j])
    return E

def checkState(B):
    global pattern_dic # lấy biến toàn cục
    
    pattern_dic = get_all_patterns(B) 
    try: # đặt trong try để bắt lỗi không tồn tại 'XXXXX' trong pattern_dic
        if pattern_dic['XXXXX'] >= 1: #tìm trong pattern_dic neu ton tại 5X
            return 1 # trả về '1'
    except Exception as e:
        pass
    # tương tự ở trên
    try:
        if pattern_dic['OOOOO']>= 1:
            return 0
    except Exception as e:
        pass
    return None

def game_over(state):
    # bảng xét xem còn chổ trống ko 
    full= True
    
 
    for i in range(S): # chạy for kiểm tra có chổ trống ko ,
                        #nếu ko giống thì full = false
        for j in range(S):
            if (state[i,j] == ''):
                full = False
                return full
    return full

def Around():
    #AR=[[a-1,b-1],[a-1,b],[a-1,b+1],[a,b-1],[a,b+1],[a+1,b-1],[a+1,b],[a+1,b+1]]
    E2=[]
    global S,B
    AR=[]
    E = Empty(B)
    for a in range(S):
        for b in range(S):
            if (B[a,b] == 'X') or (B[a,b] == 'O'):
                E2.append([a-1,b-1])
                E2.append([a-1,b])
                E2.append([a-1,b+1])
                E2.append([a,b-1])
                E2.append([a,b+1])
                E2.append([a+1,b-1])
                E2.append([a+1,b])
                E2.append([a+1,b+1])
    for i in E:
        for j in E2:
            if( j == i) and (AR.count(j) == 0):
                AR.append(j)

    return AR

def get_X():
    global B # lấy biến toàn cục B 
    pattern_dic = get_all_patterns(B)  
    score=0
    try:
        n=pattern_dic['X'] #nếu XX >= 1 thì trả về 10 
        score+= 1*n
    except Exception as e:
        pass
    try:
        n=pattern_dic['XXX']#nếu XXX >= 1 thì trả về 100 
        score+= 10*n
    except Exception as e:
        pass
    try:
        n=pattern_dic['XXXX']#nếu XXXX >= 1 thì trả về 1000 
        score+= 100*n
    except Exception as e:
        pass
    
    try:
        if pattern_dic['XXXXX']>=1:#nếu XXXX >= 1 thì trả về 1000 
            return 999999
    except Exception as e:
        pass
    
    return score

def get_O():
    global B # lấy biến toàn cục B 
    pattern_dic = get_all_patterns(B)  
    score=0
    try:
        n=pattern_dic['O'] #nếu XX >= 1 thì trả về 10 
        score+= 1*n
    except Exception as e:
        pass
    
    try:
        n=pattern_dic['OOO']#nếu XXX >= 1 thì trả về 100 
        score+= 10*n
    except Exception as e:
        pass
    
    try:
        n=pattern_dic['OOOO']#nếu XXXX >= 1 thì trả về 1000 
        score+= 100*n
    except Exception as e:
        pass

    try:
        if pattern_dic['OOOOO']>=1:#nếu XXXX >= 1 thì trả về 1000 
            return 999999
    except Exception as e:
        pass
    
    return score

def minimax(state, Maxplayer, depth = 2, alpha = -inf, beta = inf): 
    

    if (depth == 0 or game_over(state)): # hàm trả về khi depth = 0 hoặc bảng full = True
        return (get_X()-get_O(), None) # trả về bestValue của điểm X - điểm O  
    
    
    moves = Around() 
    if(Maxplayer):
        bestValue = -inf
        bestMove = None
        while moves:
            move = moves.pop()
            B[move[0],move[1]]='X'
            value, choice = minimax(state,False,depth-1, alpha, beta)
            B[move[0],move[1]]=''
            if(value > bestValue):
                bestMove = move
                bestValue = value
            # so sánh alpla vs value
            if(value >= beta):          
                break
            alpha = max(value, alpha)
        return (bestValue,bestMove)
    else:
        bestValue = inf
        bestMove = None
        while moves:
            move = moves.pop()
            B[move[0],move[1]]='O'
            value, choice = minimax(state,True,depth-1, alpha,beta)
            B[move[0],move[1]]=''
            if(value < bestValue):
                bestMove = move
                bestValue = value
            
            if(value<=alpha):
                break
            beta = min(value,beta)
        return (bestValue,bestMove)

def click(a,b):
    global B,pattern_dic,bestMove
    winner = checkState(B) 
    #với (a,b) là vị trí row,column của vị trí vừa đánh  
    if (nut[a,b]['text'] == '')and B[a,b]=='' and( winner == None):
        # check nếu vị a,b trong B, giao diện trống và winner == none
        nut[a,b]['text']=['X'] # đánh X trên giao dien
        B[a,b]='X' # đánh x trên bảng B  
        won(B)  # check thắng thua
        if bestMove != None:
            nut[bestMove[0],bestMove[1]]['text']=['O']
        bestValue, bestMove = minimax(B, True) # gọi hàm minimax
        B[bestMove[0],bestMove[1]]= 'O' # tự động đánh O vào bảng B
        nut[bestMove[0],bestMove[1]]['text']=['[O]'] # tự động đánh O vào giao diện
        
        won(B) # # check thắng thua sau khi AI đánh

import os
tk = Tk() 
tk.title("Caro")# tạo tiêu đề 
nut = {} # tạo bảng nut 
S = 12 # size của bàn cờ 
B = np.full((S,S),'') # tạo Bảng B với size S 
bestMove= None
for i in range(S):# chạy for để tạo giao diện 
    for j in range(S):
        nut[i,j]=Button(tk,font=('Time New Roman',15),bd=1,bg='gray',
                        height=1,width=3,borderwidth=2,command=partial(click,a=i,b=j))
        nut[i,j].grid(row=i,column=j)
tk.mainloop()













